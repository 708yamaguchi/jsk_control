;; Utility to deal with jsk_recognition_msgs::SimpleOccupancyGrid(Array)

(ros::roseus-add-msgs "jsk_recognition_msgs")

(defun quaternion-from-two-vectors (a b)
  (let* ((v0 (normalize-vector a))
         (v1 (normalize-vector b))
         (c (v. v1 v0)))
    (let* ((axis (v* v0 v1))
           (s (sqrt (* 2 (+ 1 c))))
           (invs (/ 1.0 s)))
      (let ((vec (scale invs axis))
            (w (* 0.5 s)))
        (normalize-vector (float-vector w (elt vec 0) (elt vec 1) (elt vec 2)))))))

(defun coefficients->plane-coords (coefficients)
  (let ((z-axis (normalize-vector (float-vector (elt coefficients 0)
                                                (elt coefficients 1)
                                                (elt coefficients 2))))
        (unitz (float-vector 0 0 1)))
    (let ((c (make-coords :rot (quaternion2matrix (quaternion-from-two-vectors unitz z-axis)))))
      (send c :translate (float-vector 0 0 (- (* 1000.0 (elt coefficients 3))))))))

(defclass occupancy-grid
  :super propertied-object
  :slots (resolution coefficients plane-coords frame-id cell-hash))

(defmethod occupancy-grid
  (:init (msg)
    "Instantiating from ros message"
    (setq frame-id (send msg :header :frame_id))
    (setq resolution (* 1000 (send msg :resolution)))
    ;; TODO: resolve tf
    (setq coefficients (send msg :coefficients))
    (setq plane-coords (coefficients->plane-coords coefficients))
    ;; hash table
    (setq cell-hash (make-hash-table :test #'equal :size 10000))
    ;; TODO: need to convert to local point??
    (dolist (cell-point (send msg :cells))
      ;; cell-point is geometry_msgs::Point
      (let ((cell-x (* 1000 (send cell-point :x)))
            (cell-y (* 1000 (send cell-point :y))))
        (let ((cell-i (/ cell-x resolution))
              (cell-j (/ cell-y resolution)))
          (setf (gethash (list cell-i cell-j) cell-hash)
                (float-vector cell-x cell-y)))))
    self)
  (:worldcoords ()
    plane-coords)
  (:vertices ()
    (let ((ret nil))
      (maphash #'(lambda (key val)
                   (setf ret (cons (send plane-coords :transform-vector (float-vector (elt val 0) (elt val 1) 0)) ret)))
               cell-hash)
      ret))
  (:collision-check-objects ()
    nil)
  (:draw (vwer)
    (gl::glPushAttrib gl::GL_ALL_ATTRIB_BITS)
    (gl::glDisable gl::GL_LIGHTING)
    
    (maphash #'(lambda (key val)
                 (let* ((center (float-vector (elt val 0) (elt val 1) 0))
                        (v1 (v+ center (float-vector resolution resolution 0)))
                        (v2 (v+ center (float-vector (- resolution) resolution 0)))
                        (v3 (v+ center (float-vector (- resolution) (- resolution) 0)))
                        (v4 (v+ center (float-vector resolution (- resolution) 0))))
                   (let ((gv1 (send plane-coords :transform-vector v1))
                         (gv2 (send plane-coords :transform-vector v2))
                         (gv3 (send plane-coords :transform-vector v3))
                         (gv4 (send plane-coords :transform-vector v4)))
                     (gl::glBegin gl::GL_LINE_STRIP)
                     (gl::glColor3fv #.(float-vector 1 0 0))
                     (gl::glVertex3fv gv1)
                     (gl::glColor3fv #.(float-vector 1 0 0))
                     (gl::glVertex3fv gv2)
                     (gl::glColor3fv #.(float-vector 1 0 0))
                     (gl::glVertex3fv gv3)
                     (gl::glColor3fv #.(float-vector 1 0 0))
                     (gl::glVertex3fv gv4)
                     (gl::glColor3fv #.(float-vector 1 0 0))
                     (gl::glVertex3fv gv1)
                     (gl::glEnd)
                     )))
             cell-hash)
    (gl::glEnable gl::GL_LIGHTING)
    (gl::glPopAttrib)
    )
  )

#|
(load "package://jsk_footstep_planner/euslisp/simple_occupancy_grid.l")
(ros::roseus "hoge")
(defun callback (msg)
  (setq *grids* (mapcar #'(lambda (g)
                            (instance occupancy-grid :init g))
                        (send msg :grids)))
  (objects *grids*))
(ros::subscribe "/locomotion/env_server/output" jsk_recognition_msgs::SimpleOccupancyGridArray #'callback)
(ros::spin-once)
|#